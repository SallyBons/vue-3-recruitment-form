import { isRef, reactive, computed, watch, ref, getCurrentInstance, inject, provide, onBeforeUnmount } from 'vue-demi';

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function unwrap(val) {
  return isRef(val) ? val.value : val;
}
function unwrapObj(obj) {
  var ignoreKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return Object.keys(obj).reduce(function (o, k) {
    if (ignoreKeys.includes(k)) return o;
    o[k] = unwrap(obj[k]);
    return o;
  }, {});
}
function isFunction(val) {
  return typeof val === 'function';
}
function isObject(val) {
  return val !== null && (_typeof(val) === 'object' || isFunction(val));
}
function isPromise(object) {
  return isObject(object) && isFunction(object.then);
}

/**
 * @typedef NormalizedValidator
 * @property {Validator} $validator
 * @property {String | Ref<String> | function(*): string} [$message]
 * @property {Object | Ref<Object>} [$params]
 */

/**
 * Response form a raw Validator function.
 * Should return a Boolean or an object with $invalid property.
 * @typedef {Boolean | { $invalid: Boolean }} ValidatorResponse
 */

/**
 * Raw validator function, before being normalized
 * Can return a Promise or a {@see ValidatorResponse}
 * @typedef {function(*): ((Promise<ValidatorResponse> | ValidatorResponse))} Validator
 */

/**
 * Sorts the validators for a state tree branch
 * @param {Object<NormalizedValidator|Function>} validationsRaw
 * @return {{ rules: Object<NormalizedValidator>, nestedValidators: Object, config: Object }}
 */

function sortValidations() {
  var validationsRaw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var validations = unwrap(validationsRaw);
  var validationKeys = Object.keys(validations);
  var rules = {};
  var nestedValidators = {};
  var config = {};
  validationKeys.forEach(function (key) {
    var v = validations[key];

    switch (true) {
      // If it is already normalized, use it
      case isFunction(v.$validator):
        rules[key] = v;
        break;
      // If it is just a function, normalize it first
      // into { $validator: <Fun> }

      case isFunction(v):
        rules[key] = {
          $validator: v
        };
        break;
      // Catch $-prefixed properties as config

      case key.startsWith('$'):
        config[key] = v;
        break;
      // If it doesn’t match any of the above,
      // treat as nestedValidators state property

      default:
        nestedValidators[key] = v;
    }
  });
  return {
    rules: rules,
    nestedValidators: nestedValidators,
    config: config
  };
}
/**
 * Calls a validation rule by unwrapping it's value first from a ref.
 * @param {Validator} rule
 * @param {Ref} value
 * @return {Promise<ValidatorResponse> | ValidatorResponse}
 */


function callRule(rule, value) {
  var v = unwrap(value);
  return rule(v);
}
/**
 * Normalizes the validator result
 * Allows passing a boolean of an object like `{ $invalid: Boolean }`
 * @param {ValidatorResponse} result - Validator result
 * @return {Boolean}
 */


function normalizeValidatorResponse(result) {
  return result.$invalid !== undefined ? !result.$invalid : !result;
}
/**
 * Returns the result of the validator every time the model changes.
 * Wraps the call in a computed property.
 * Used for with normal functions.
 * TODO: This allows a validator to return $invalid, probably along with other parameters. We do not utilize them ATM.
 * @param {Validator} rule
 * @param {Ref<*>} model
 * @param {Ref<boolean>} $dirty
 * @return {Ref<Boolean>}
 */


function createComputedResult(rule, model, $dirty) {
  return computed(function () {
    // if $dirty is false, we dont validate at all.
    // TODO: Make this optional, this is a huge breaking change
    if (!$dirty.value) return false;
    var result = callRule(rule, unwrap(model)); // if it returns a promise directly, error out

    if (isPromise(result)) {
      throw Error('[vuelidate] detected a raw async validator. Please wrap any async validators in the `withAsync` helper.');
    }

    return normalizeValidatorResponse(result);
  });
}
/**
 * Returns the result of an async validator.
 * @param {Function} rule
 * @param {Ref<*>} model
 * @param {Ref<Boolean>} $pending
 * @param {Ref<Boolean>} $dirty
 * @return {Ref<Boolean>}
 */


function createAsyncResult(rule, model, $pending, $dirty) {
  var $invalid = ref(!!$dirty.value);
  var $pendingCounter = ref(0);
  $pending.value = false;
  watch([model, $dirty], function (modelValue) {
    if (!$dirty.value) return false;
    var ruleResult = callRule(rule, model);
    $pendingCounter.value++;
    $pending.value = !!$pendingCounter.value;
    $invalid.value = true;
    ruleResult.then(function (data) {
      $pendingCounter.value--;
      $pending.value = !!$pendingCounter.value;
      $invalid.value = normalizeValidatorResponse(data);
    })["catch"](function () {
      $pendingCounter.value--;
      $pending.value = !!$pendingCounter.value;
      $invalid.value = true;
    });
  }, {
    flush: 'sync'
  });
  return $invalid;
}
/**
 * Returns the validation result.
 * Detects async and sync validators.
 * @param {NormalizedValidator} rule
 * @param {Object} state
 * @param {String} key
 * @return {{$params: *, $message: Ref<String>, $pending: Ref<Boolean>, $invalid: Ref<Boolean>}}
 */


function createValidatorResult(rule, state, key, $dirty) {
  var model = computed(function () {
    var s = unwrap(state);
    return s ? unwrap(s[key]) : null;
  });
  var $pending = ref(false);
  var $params = rule.$params || {};
  var $invalid = rule.$async ? createAsyncResult(rule.$validator, model, $pending, $dirty) : createComputedResult(rule.$validator, model, $dirty);
  var message = rule.$message;
  var $message = isFunction(message) ? computed(function () {
    return message(unwrapObj({
      $pending: $pending,
      $invalid: $invalid,
      $params: unwrapObj($params),
      // $params can hold refs, so we unwrap them for easy access
      $model: model
    }));
  }) : message || '';
  return {
    $message: $message,
    $params: $params,
    $pending: $pending,
    $invalid: $invalid
  };
}
/**
 * @typedef ErrorObject
 * @property {Ref<String>} $message - Reactive error message
 * @property {Ref<Object>} $params - Params passed from withParams
 * @property {Ref<Boolean>} $pending - If validation is pending
 * @property {String} $property - State key
 * @property {String} $propertyPath - Dot notation path to state
 * @property {String} $validator - Validator name
 */

/**
 * @typedef ValidationResult
 * @property {Ref<Boolean>} $pending
 * @property {Ref<Boolean>} $dirty
 * @property {Ref<Boolean>} $invalid
 * @property {Ref<Boolean>} $error
 * @property {Function} $touch
 * @property {Function} $reset
 * @property {Ref<ErrorObject[]>} $errors
 */

/**
 * Creates the main Validation Results object for a state tree
 * Walks the tree's top level branches
 * @param {Object<NormalizedValidator>} rules - Rules for the current state tree
 * @param {Object} state - Current state tree
 * @param {String} key - Key for the current state tree
 * @param {String} [parentKey] - Parent key of the state. Optional
 * @param {Map} [resultsCache] - A cache map of all the validators
 * @param {String} [path] - the current property path
 * @return {ValidationResult | {}}
 */


function createValidationResults(rules, state, key, parentKey, resultsCache, path) {
  // collect the property keys
  var ruleKeys = Object.keys(rules);
  var cachedResult = resultsCache.get(path);
  var $dirty = cachedResult ? cachedResult.$dirty : ref(false);
  var result = {
    // restore $dirty from cache
    $dirty: $dirty,
    $touch: function $touch() {
      if (!$dirty.value) $dirty.value = true;
    },
    $reset: function $reset() {
      if ($dirty.value) $dirty.value = false;
    }
  };
  /**
   * If there are no validation rules, it is most likely
   * a top level state, aka root
   */

  if (!ruleKeys.length) return result;
  ruleKeys.forEach(function (ruleKey) {
    result[ruleKey] = createValidatorResult(rules[ruleKey], state, key, result.$dirty);
  });
  result.$invalid = computed(function () {
    return ruleKeys.some(function (ruleKey) {
      return unwrap(result[ruleKey].$invalid);
    });
  });
  result.$pending = computed(function () {
    return ruleKeys.some(function (ruleKey) {
      return unwrap(result[ruleKey].$pending);
    });
  });
  result.$error = computed(function () {
    return result.$invalid.value && result.$dirty.value;
  });
  result.$errors = computed(function () {
    return ruleKeys.filter(function (ruleKey) {
      return unwrap(result[ruleKey].$invalid);
    }).map(function (ruleKey) {
      var res = result[ruleKey];
      return reactive({
        $propertyPath: path,
        $property: key,
        $validator: ruleKey,
        $message: res.$message,
        $params: res.$params,
        $pending: res.$pending
      });
    });
  });
  resultsCache.set(path, result);
  return result;
}
/**
 * Collects the validation results of all nested state properties
 * @param {Object<NormalizedValidator|Function>} validations - The validation
 * @param {Object} state - Parent state
 * @param {String} [key] - Parent level state key
 * @param {String} path - Path to current property
 * @param {Map} resultsCache - Validations cache map
 * @return {{}}
 */


function collectNestedValidationResults(validations, state, key, path, resultsCache) {
  var nestedValidationKeys = Object.keys(validations); // if we have no state, return empty object

  if (!nestedValidationKeys.length) return {};
  return nestedValidationKeys.reduce(function (results, nestedKey) {
    // if we have a key, use the nested state
    // else use top level state
    var nestedState = key ? computed(function () {
      return unwrap(unwrap(state)[key]);
    }) : state; // build validation results for nested state

    results[nestedKey] = setValidations({
      validations: validations[nestedKey],
      state: nestedState,
      key: nestedKey,
      parentKey: path,
      resultsCache: resultsCache
    });
    return results;
  }, {});
}
/**
 * Generates the Meta fields from the results
 * @param {ValidationResult|{}} results
 * @param {Object<ValidationResult>[]} nestedResults
 * @param {Object<ValidationResult>[]} childResults
 * @return {{$anyDirty: Ref<Boolean>, $error: Ref<Boolean>, $invalid: Ref<Boolean>, $errors: Ref<ErrorObject[]>, $dirty: Ref<Boolean>, $touch: Function, $reset: Function }}
 */


function createMetaFields(results, nestedResults, childResults) {
  // use the $dirty property from the root level results
  var $dirty = results.$dirty;
  var allResults = computed(function () {
    return [nestedResults, childResults].filter(function (res) {
      return res;
    }).reduce(function (allRes, res) {
      return allRes.concat(Object.values(unwrap(res)));
    }, []);
  });
  var $errors = computed(function () {
    // current state level errors, fallback to empty array if root
    var modelErrors = unwrap(results.$errors) || []; // collect all nested and child $errors

    var nestedErrors = allResults.value.filter(function (result) {
      return unwrap(result).$errors.length;
    }).reduce(function (errors, result) {
      return errors.concat.apply(errors, _toConsumableArray(result.$errors));
    }, []); // merge the $errors

    return modelErrors.concat(nestedErrors);
  });
  var $invalid = computed(function () {
    return (// if any of the nested values is invalid
      allResults.value.some(function (r) {
        return r.$invalid;
      }) || // or if the current state is invalid
      unwrap(results.$invalid) || // fallback to false if is root
      false
    );
  });
  var $pending = computed(function () {
    return (// if any of the nested values is pending
      allResults.value.some(function (r) {
        return unwrap(r.$pending);
      }) || // if any of the current state validators is pending
      unwrap(results.$pending) || // fallback to false if is root
      false
    );
  });
  var $anyDirty = computed(function () {
    return allResults.value.some(function (r) {
      return r.$dirty;
    }) || $dirty.value;
  });
  var $error = computed(function () {
    return $invalid.value && $dirty.value || false;
  });

  var $touch = function $touch() {
    // call the root $touch
    results.$touch(); // call all nested level $touch

    Object.values(allResults.value).forEach(function (result) {
      result.$touch();
    });
  };

  var $reset = function $reset() {
    // reset the root $dirty state
    results.$reset(); // reset all the children $dirty states

    Object.values(allResults.value).forEach(function (result) {
      result.$reset();
    });
  };

  return {
    $dirty: $dirty,
    $errors: $errors,
    $invalid: $invalid,
    $anyDirty: $anyDirty,
    $error: $error,
    $pending: $pending,
    $touch: $touch,
    $reset: $reset
  };
}
/**
 * @typedef VuelidateState
 * @property {Boolean} $anyDirty
 * @property {Boolean} $error
 * @property {Boolean} $pending
 * @property {Boolean} $invalid
 * @property {ErrorObject[]} $errors
 * @property {*} [$model]
 * @property {Function} $touch
 * @property {Boolean} $dirty
 * @property {Function} $reset
 * @property {Function} $validate
 * @property {Function} $getResultsForChild
 */

/**
 * Main Vuelidate bootstrap function.
 * Used both for Composition API in `setup` and for Global App usage.
 * Used to collect validation state, when walking recursively down the state tree
 * @param {Object} params
 * @param {Object<NormalizedValidator|Function>} params.validations
 * @param {Object} params.state
 * @param {String} [params.key] - Current state property key. Used when being called on nested items
 * @param {String} [params.parentKey] - Parent state property key. Used when being called recursively
 * @param {Object<ValidationResult>} [params.childResults] - Used to collect child results.
 * @param {Map} resultsCache - The cached validation results
 * @return {UnwrapRef<VuelidateState>}
 */


function setValidations(_ref) {
  var validations = _ref.validations,
      state = _ref.state,
      key = _ref.key,
      parentKey = _ref.parentKey,
      childResults = _ref.childResults,
      resultsCache = _ref.resultsCache;
  var path = parentKey ? "".concat(parentKey, ".").concat(key) : key; // Sort out the validation object into:
  // – rules = validators for current state tree fragment
  // — nestedValidators = nested state fragments keys that might contain more validators
  // – config = configuration properties that affect this state fragment

  var _sortValidations = sortValidations(validations),
      rules = _sortValidations.rules,
      nestedValidators = _sortValidations.nestedValidators,
      config = _sortValidations.config; // Use rules for the current state fragment and validate it


  var results = createValidationResults(rules, state, key, parentKey, resultsCache, path); // Use nested keys to repeat the process
  // *WARN*: This is recursive

  var nestedResults = collectNestedValidationResults(nestedValidators, state, key, path, resultsCache); // Collect and merge this level validation results
  // with all nested validation results

  var _createMetaFields = createMetaFields(results, nestedResults, childResults),
      $dirty = _createMetaFields.$dirty,
      $errors = _createMetaFields.$errors,
      $invalid = _createMetaFields.$invalid,
      $anyDirty = _createMetaFields.$anyDirty,
      $error = _createMetaFields.$error,
      $pending = _createMetaFields.$pending,
      $touch = _createMetaFields.$touch,
      $reset = _createMetaFields.$reset;
  /**
   * If we have no `key`, this is the top level state
   * We dont need `$model` there.
   */


  var $model = key ? computed({
    get: function get() {
      return unwrap(unwrap(state)[key]);
    },
    set: function set(val) {
      $dirty.value = true;
      var unwrappedState = unwrap(state);

      if (isRef(unwrappedState[key])) {
        unwrappedState[key].value = val;
      } else {
        unwrappedState[key] = val;
      }
    }
  }) : null;

  if (config.$autoDirty) {
    watch(function () {
      return unwrap(unwrap(state)[key]);
    }, function () {
      if (!$dirty.value) $touch();
    });
  }

  function $validate() {
    return new Promise(function (resolve) {
      if (!$dirty.value) $touch(); // return whether it is valid or not

      if (!$pending.value) return resolve(!$error.value);
      var unwatch = watch($pending, function () {
        resolve(!$error.value);
        unwatch();
      });
    });
  }
  /**
   * Returns a child component's results, based on registration name
   * @param {string} key
   * @return {VuelidateState}
   */


  function $getResultsForChild(key) {
    return (childResults.value || {})[key];
  }

  return reactive(Object.assign({}, results, {
    // NOTE: The order here is very important, since we want to override
    // some of the *results* meta fields with the collective version of it
    // that includes the results of nested state validation results
    $model: $model,
    $dirty: $dirty,
    $error: $error,
    $errors: $errors,
    $invalid: $invalid,
    $anyDirty: $anyDirty,
    $pending: $pending,
    $touch: $touch,
    $reset: $reset
  }, childResults && {
    $getResultsForChild: $getResultsForChild,
    $validate: $validate
  }, {}, nestedResults));
}

var VuelidateInjectChildResults = Symbol('vuelidate#injectChiildResults');
var VuelidateRemoveChildResults = Symbol('vuelidate#removeChiildResults');
/**
 * Composition API compatible Vuelidate
 * Use inside the `setup` lifecycle hook
 * @param {Object} validations - Validations Object
 * @param {Object} state - State object
 * @param {String} registerAs - a registration name, when registering results to the parent validator.
 * @return {UnwrapRef<*>}
 */

function useVuelidate(validations, state, registerAs) {
  // if there is no registration name, add one.
  if (!registerAs) {
    var instance = getCurrentInstance(); // NOTE:
    // ._uid // Vue 2.x Composition-API plugin
    // .uid // Vue 3.0

    var uid = instance.uid || instance._uid;
    registerAs = "_vuelidate_".concat(uid);
  }

  var resultsCache = new Map();
  var childResultsRaw = {};
  var childResultsKeys = ref([]);
  var childResults = computed(function () {
    return childResultsKeys.value.reduce(function (results, key) {
      results[key] = unwrap(childResultsRaw[key]);
      return results;
    }, {});
  });
  /**
   * Allows children to send validation data up to their parent.
   * @param {Object} results - the results
   * @param {String} key - the registeredAs key
   */

  function injectChildResultsIntoParent(results, key) {
    childResultsRaw[key] = results;
    childResultsKeys.value.push(key);
  }
  /**
   * Allows children to remove the validation data from their parent, before getting destroyed.
   * @param {String} key - the registeredAs key
   */


  function removeChildResultsFromParent(key) {
    // remove the key
    childResultsKeys.value = childResultsKeys.value.filter(function (childKey) {
      return childKey !== key;
    }); // remove the stored data for the key

    delete childResultsRaw[key];
  }

  var sendValidationResultsToParent = inject(VuelidateInjectChildResults, function () {}); // provide to all of it's children the send results to parent function

  provide(VuelidateInjectChildResults, injectChildResultsIntoParent);
  var removeValidationResultsFromParent = inject(VuelidateRemoveChildResults, function () {}); // provide to all of it's children the remove results  function

  provide(VuelidateRemoveChildResults, removeChildResultsFromParent);
  var validationResults = computed(function () {
    return setValidations({
      validations: unwrap(validations),
      state: state,
      childResults: childResults,
      resultsCache: resultsCache
    });
  }); // send all the data to the parent when the function is invoked inside setup.

  sendValidationResultsToParent(validationResults, registerAs); // before this component is destroyed, remove all the data from the parent.

  onBeforeUnmount(function () {
    return removeValidationResultsFromParent(registerAs);
  }); // TODO: Change into reactive + watch

  return computed(function () {
    return Object.assign({}, validationResults.value, {}, childResults.value);
  });
}
/**
 * Vuelidate mixin, used to attach Vuelidate only to specified components
 * Relies on `validations` option to be defined on component instance
 * @type {ComponentOptions}
 */

var VuelidateMixin = {
  computed: {},
  beforeCreate: function beforeCreate() {
    var _this = this;

    var resultsCache = new Map();
    var options = this.$options;
    if (!options.validations) return;
    if (options.computed.$v) return;
    var validations = computed(function () {
      return isFunction(options.validations) ? options.validations.call(_this) : options.validations;
    });
    var $v;

    options.computed.$v = function () {
      var _this2 = this;

      if ($v) {
        return $v.value;
      } else {
        $v = computed(function () {
          return setValidations({
            validations: validations,
            state: _this2,
            resultsCache: resultsCache
          });
        });
        return $v.value;
      }
    };
  }
};
/**
 * Default way to install Vuelidate globally for entire app.
 * @param {Vue} app
 */

var VuelidatePlugin = {
  install: function install(app) {
    app.mixin(VuelidateMixin);
  }
};

export default useVuelidate;
export { VuelidateMixin, VuelidatePlugin, useVuelidate };
